#include <random>
#include <iostream>

#include <iomanip>
#include <string>
#include <map>
#include <random>
#include <cmath>
#include <algorithm>

#include <omp.h>
#include <unistd.h>

#include <pthread.h>
#include "perf_lfu.cpp"
//#include "perf2.cpp"
 
// Do not use the normal_distribution output as access indices directly.
// A more realistic setting is to randomly pick 

long readvar[64]; 

int main() {
    // start perf monitornig thread
    pthread_t perf_thread;
    int r = pthread_create(&perf_thread, NULL, perf_func, NULL);
    if (r != 0) {
      std::cout << "pthread create failed." << std::endl;
      exit(1);
    }
    std::cout << "perf thread created." << std::endl;

    //progressbar bar(100);
    int NUM_THREADS=omp_get_max_threads();
    std::cout<<"threads="<<omp_get_max_threads()<<std::endl;

    const long ITERS = 12;
    //long numAccess = 40000000;
    long numAccess = 200000000;
    //long numAccess = 5240000;
    std::cout << "Runnign for " << ITERS*numAccess/1000000 << "M iterations." << std::endl;

    std::random_device rd{};
    std::mt19937 gen{rd()};
 
    // values near the mean are the most likely
    // standard deviation affects the dispersion of generated values from the mean
    std::normal_distribution<> d{4000000, 313000};
    //std::normal_distribution<> d{4000000, 30000};

    //char a = new char[1024*1024];
    const long rows = 8L*1024L*1024L; // 8M rows
    const long rowSizeBytes = 4096; // in bytes
    const long rowSize = rowSizeBytes/sizeof(int) ; // in number of ints

    const size_t size = rows*rowSize;
    int* arr = new int[size];
    std::cout << rows*rowSize << std::endl;
    // initialize chunk of memory
    #pragma omp parallel for
    for(size_t i = 0; i < size; ++i) {
        arr[i] = i%100000;
        //std::cout << arr[i] << std::endl;
    }
    std::cout << "done initialization " << std::endl;

    // used as an indirection to map rows generated by normal_distribution to random rows
    long* rowAccesses = new long[rows]; 

    // Initialize 
    for(int i = 0; i < rows; ++i) {
        rowAccesses[i] = i;
    }

    //int** arr = new int*[rows];
    //for(int i = 0; i < rows; ++i) {
    //    arr[i] = new int[rowSize];
    //    rowAccesses[i] = i;
    //}

    std::random_shuffle(&(rowAccesses[0]), &(rowAccesses[rows-1]));
    
    std::cout << "starting addr: " << &(arr[0]) << std::endl;
    //std::cout << "hottest addr: " << &(arr[4000000*rowSize]) << std::endl;
    std::cout << " ending addr: " << &(arr[(rows-1)*rowSize]) << std::endl;

    //std::cout << "arr starting addr: " << &(arr[0]) << std::endl;
    //std::cout << "arr ending addr: " << &(arr[rows-1]) << std::endl;

    //int numAccess = 80000;
    //std::map<long, long> hist = std::map<long, long>();
    long* dist = new long[numAccess];
    long* hist = new long[rows];

    std::cout << "generating requests now" << std::endl;
    #pragma omp parallel for
    for (long n = 0; n < numAccess; ++n) {
      long randRow = std::round(d(gen));
      //dist[n] = randRow;
      dist[n] = rowAccesses[randRow]; // indirection
      #pragma omp critical 
      {
      ++(hist[dist[n]]);
      }
    }

    // print out addresses that makes up the hot set.
    // manually calculating this for now.
    // let us say that the hot set is within one std deviation of the mean (68% of accesses).
    // e.g. for 8M accesses, 68% is 5.44M accesses. These 5.44M accesses are distributed to stddev*2 rows.
    // If std dev = 400, this means 6.8k accesses per row on average.
    // Lets divide that by 1.5 and say that any row with >4.5k accesses are hot.
    // I THINK this is roughly +-1 std dev. 
    //#pragma omp parallel for
    //for (long n = 0; n < numAccess; ++n) {
    //  // count number of requests to each row
    //  ++(hist[dist[n]]);
    //}
    
    // 200M accesses, 68% is 136M. std-dev = 313k -> ~217 accesses per row

    std::cout << "printing hot key addresses" << std::endl;

//    for(auto [row, count] : hist) {
    for (long row = 0; row < rows; ++row) {
      long count = hist[row];
      if (count >= 220) {
      //if (count >= 144) {
        //std::cout << std::dec << "row " << row << " is hot with " << count << " accesses. Address is " << std::hex << &(arr[row*rowSize]) << std::endl;
      }
    } 
    std::cout << "index generation done" << std::endl;

    //for (int iter = 0; iter < 4; ++iter) { 
    //std::cout << "iter " << iter << std::endl;
    #pragma omp parallel for
    for (long n = 0; n < numAccess*ITERS; ++n) { // repeatedly reuse the same generated requests
      long true_n = n % numAccess;
      for (long i = 0; i < rowSize; ++i) {
        int t = omp_get_thread_num();
        readvar[t] = arr[dist[true_n]*rowSize+i]; // row = dist[n]*rowSize, col = i
        //readvar[t] = arr[dist[n]][i];
        //if (dist[n]*rowSize+i > size ) {  
        //std::cout << " index: " << dist[n]*rowSize+i << std::endl;
        //if (readvar[t] < 0 ) {  
        //    std::cout << " index: " << dist[n]*rowSize+i << std::endl;
        //    std::cout << " readvar: " << readvar[t] << std::endl;
        //}
      }
    }

    for (int n = 0; n < NUM_THREADS; ++n) {
      std::cout << std::dec << readvar[n] << std::endl;
    }

}
